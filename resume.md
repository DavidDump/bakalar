<!-- ### Abstrakt -->
Táto práca predstavuje návrh a implementáciu Benexu, staticky typovaného programovacieho jazyka zameraného na zníženie syntaktickej zložitosti pri generovaní natívneho strojového kódu x86. Architektúra kompilátora pozostáva z frontendu (lexer, parser, kontrola typov) a backendu (generátor kódu, asembler), pričom jeho výsledkom sú spustiteľné súbory pre Windows, typu PE32. Benex kladie dôraz na ergonómiu vývojárov zjednodušením vyjadrovania zámerov prostredníctvom moderných funkcií, ako sú generické funkcie, dynamické polia a modulárne implementácie v používateľskom priestore. Jazyk uprednostňuje sémantickú správnosť, flexibilitu a vyhýba sa rigidným programovacím paradigmám. Práca je kontextualizovaná v rámci formálnej teórie jazykov, Turingovej úplnosti a kódovania inštrukcií x86 s praktickým overením prostredníctvom vzorových programov a podrobného procesu konštrukcie kompilátora.

<!-- ### Motivácia a vplyvy -->
Benex sa zaoberá obmedzeniami ktoré sa objavujú v systémových jazykoch, ako sú C a Rust, najmä ich syntaktickou rozvláčnosťou a požiadavkami na manuálnu správu pamäte. Inšpirovaný jazykom Jai, ktorý vytvoril Jonathan Blow, sa Benex snaží o rovnováhu medzi nízkoúrovňovou kontrolou a vysokoúrovňovou expresivitou. Medzi kľúčové ciele patrí minimalizácia kognitívnej záťaže prostredníctvom automatickej typovej inferencie, redukcia kotlového kódu (napr. implicitné dereferencovanie ukazovateľov) a umožnenie rýchlej iterácie. Kompilátor zostáva nenáročný a deleguje pokročilé funkcie, ako je spracovanie reťazcov, na modulárne komponenty runtime, ktoré si používatelia môžu prispôsobiť alebo vypnúť. Táto filozofia návrhu je v súlade so zásadou, že programovanie by malo byť intuitívne a radostné, pričom podporuje prehľadnosť bez obetovania výkonu.

<!-- ### Teória a návrh jazyka -->
Základom Benexu je formálna teória jazyka, ktorá využíva bezkontextovú gramatiku analyzovanú pomocou algoritmu recursive descent. Jazyk je Turingov kompletný, podporuje cykly, podmienené vetvenie a rekurzívne funkcie. Abstraktný syntaktický strom (AST) slúži ako sprostredkovaná reprezentácia, ktorá abstrahuje od syntaktických detailov a zameriava sa na logickú štruktúru. Kompilátor sa zameriava na architektúru x86 a využíva inštrukcie s premenlivou dĺžkou (1-15 bajtov) s komponentmi, ako sú prefixy `REX`, bajty `ModR/M` a režimy adresovania `SIB`. Pri generovaní asembleru sa používa syntax Intel, pričom sa zdôrazňuje poradie operandov podľa cieľa a explicitné dimenzovanie registrov (napr. `rax` pre 64-bitové, `eax` pre 32-bitové). Tok riadenia sa spolieha na inštrukcie skoku (napr. `JMP`, `JE`) a porovnávanie registrov `EFLAGS`, čo umožňuje deterministické vetvenie.

<!-- ### Architektúra kompilátora -->
Kompilácia sa začína lexerom, ktorý tokenizuje zdrojový kód, odstraňuje biele znaky a komentáre a zároveň sleduje umiestnenie tokenov na účely hlásenia chýb. Parser s rekurzívnym zostupom overuje syntax a vytvára AST s anotáciami volaní funkcií, literálov a riadiacich štruktúr. Kontrolór typov presadzuje sémantické pravidlá, rieši závislosti symbolov a overuje platnosť výrazov (napr. zákaz `1 + "text"`). Číselné typy sú odvodené na `s64` a `f64`, ak nie je uvedený explicitný typ. Backend generuje asembler x86 pomocou prístupu založeného na zásobníku pre medziľahlé hodnoty, zatiaľ čo asembler mapuje mnemotechniky na strojový kód pomocou vyhľadávacích tabuliek. Nakoniec generátor PE32 balí kód, údaje a metadáta do spustiteľných súborov systému Windows, pričom dodržiava formát hlavičky COFF a importné tabuľky pre externé knižnice, ako je `kernel32.dll`.

<!-- ### Špecifikácie jazyka -->
Syntax jazyka kladie dôraz na stručnosť a prehľadnosť. Literály zahŕňajú celé čísla (s prefixmi `0x` a `0b` pre hex/bin), floaty, reťazce UTF-8 (podporujúce escape sekvencie) a inicializátory štruktúr/enumov. Konštanty (`::`) a premenné (`:=`) sa riešia v čase kompilácie, resp. v čase behu. Tok riadenia obsahuje jednotnú konštrukciu `loop` pre pevné iterácie (`loop 5`), podmienené cykly (`loop x < 5`) a prechádzanie kolekcií (`loop elem in array`). Zátvorky v podmienkach `if` sú nepovinné a `defer` zabezpečuje vykonanie čistiacich akcií pri ukončení oboru. Funkcie podporujú overloading, variabilné parametre (`...`) a generické parametre (`$T`), pričom asercie v čase kompilácie (`#assert_param`) garantujú typové obmedzenia. Štruktúry a enumy akceptujú parametrizované typy (napr. `hashmap(string, u8)`), implementácia reťazcov a dynamickích polý je umožnené pomocou struktúr.

<!-- ### Systém typov a sémantika -->
Statický typový systém Benexu zahŕňa primitíva (`u8`, `f64`, `bool`), používateľom definované štruktúry/enumy a funkčné typy. Generické typy umožňujú opakované použitie kódu, pričom typové parametre sú odvodené alebo explicitne špecifikované. Napríklad generická funkcia `add` obmedzuje vstupy na číselné typy prostredníctvom `#assert_param(isNumber(T))`, čím zabezpečuje validáciu v čase kompilácie. Štruktúry podporujú pozičné a určené inicializátory (napr. `Vec2{1, 2}` alebo `Vec2{.x=1, .y=2}`), zatiaľ čo enumy mapujú pomenované hodnoty na čísla (napr. `Color.RED = 0`). Reťazce sa zjednoduhšujú na štruktúru s poliami `length` a `data` a dynamické polia abstrahujú správu pamäte prostredníctvom sledovania kapacity a veľkosti.

<!-- ### Generovanie kódu -->
Backend vysiela inštrukcie x86. Napríklad príkaz `print("Hello World")` sa prekladá do asembleru, ktorý načíta adresu reťazca do `rcx`, upraví zásobník a zavolá importovanú funkciu `print`. Asembler tieto kroky zakóduje do strojového kódu (napr. `0x55` pre `PUSH rbp`). Hoci súčasná implementácia uprednostňuje správnosť pred optimalizáciou, budúca práca by sa mohla zamerať na implementáciu optimalizačného kroku pred generovaním konečného bajtkódu. Generátor PE32 štruktúruje spustiteľné súbory pomocou hlavičiek (DOS, COFF), sekcií (`.text`, `.data`) a importných tabuliek, čím zabezpečuje kompatibilitu so spustiteľnými prostrediami Windows.

<!-- ### Záver a budúce smery -->
Benex demonštruje funkčný kompilátor pre moderný systémový jazyk, ktorý vyvažuje expresivitu a výkon. Jeho modulárna architektúra umožňuje postupné vylepšovanie, napríklad rozširovanie štandardných knižníc o dátové štruktúry (napr. hashové mapy) alebo abstrakcie OS. Budúca práca by mala zdokonaliť diagnostiku prostredníctvom podrobných chybových hlásení a integrácie ladiacich symbolov. Rozšírenie backendu o podporu architektúr ARM by rozšírilo použiteľnosť na vstavané systémy. Vývoj projektu je dobre zdokumentovaný vo viac ako 250 revíziách na GitHub. Prepojením teoretických konceptov (napr. Turingova úplnosť, formálne gramatiky) s praktickou implementáciou prispieva Benex k diskurzu o návrhu jazykov a programovaní nízkoúrovňových systémov.
