These instructions follow the same pattern in their syntax, the first operand is the destination and the second is the source. In the following examples `rax` contains 34 and `rbx` contains 35.
#### AND example:
```asm
; 34 = 0b100010
; 35 = 0b100011
; AND ----------
;      0b100010
AND rax, rbx    ; rax = rax & rbx
```
#### OR example:
```asm
; 34 = 0b100010
; 35 = 0b100011
; OR  ----------
;      0b100011
OR rax, rbx     ; rax = rax | rbx
```
#### XOR example:
```asm
; 34 = 0b100010
; 35 = 0b100011
; XOR ----------
;      0b000001
XOR rax, rbx     ; rax = rax ^ rbx
```

The NOT instrucion only has one operand, it simply inverts all the bits.
```asm
MOV rax, 42     ; 0b101010
NOT rax         ; after the instruction rax will contain 0b010101
```

### Shift Instructions
Shift instructions shift the bits in a register, or memory location to the left or right. There are two types of shift instructions: regular (`SHL`, `SHR`) and arithmetic (`SAL`, `SAR`). Both regular and arithmetic shifts behave the same way when shifting to the left, the LSB that is shifter in is always a `0`. When shifting to the right a regular shift will shift in a `0`, an arithmetic shift will shift in the sign bit.
The operands can be specified in two ways. The first operand is always the target register or memory location. This is were the bits are stored that will be shifted. The second operand can be a 8 bit number or the `cl` register. If it is a number the target bits will be shifted this number of times. If its the `cl` register the value stored in the register is how many times the bits will be shifted.
Shifting to the left is also equivalent to multiplying by two, and shifting to the right is the equivalent to dividing by two. When multiplying or dividing signed or unsigned number the arithmeric or regular shifts need to be used respectively for the result to be correct. These instruction are ofter used for optimizing division or multiplication by a multiple of two, as these instructions are faster than the regular `DIV` and `MUL` instructions.

Examples of using shift instructions:
```asm
; shift bits in rax to the right by one, shift in a 0 bit
SHR rax, 1

; shift bits in rbx to the left the amount stored in cl,
; shift in a 0 bit
SAL rbx, cl

; shift bits at the memory location
; that is stored in rbp - 8 to the right,
; shift in the same bit as MSB
SAR QWORD [rbp - 8], 2
```

### Flow Control Instrucions
Flow control instructions modify the value stored in the `rip`, instruction pointer, register. This allows the CPU to execute instructions in a different order than it is stored in memory. The `JMP` (jump) instruction is the simplest flow control instruction. The `JMP` instruction takes one argument, the memory address that should be stored in the `rip` register, or simply put, the target address where it should jump to.
```asm
jmp 0xFFFF ; jumps to the absolute address 0xFFFF
```
A different form of the `JMP` istruction is the conditional jump, this group of instructions also performs a jump to a target address, but only if a certaint condition is met. All the conditions are related to the `EFLAGS` register, and are true if one or more flags in the `EFLAGS` register are set, depending on the instruction.
The various flags that are stored in the `EFLAGS` register are set based on the result of the  last arithmetic operation performed. The flags are:
