The objective of this work was to investigate the underlying architecture of a compiler by developing a demonstrative example that integrates all the requisite stages for generating a Windows executable. In this study, we examined various methodologies for parsing formal languages, deliberated on aspects of computational theory and Turing completeness, and investigated the encoding of bytecode instructions specific to the x86 architecture. Additionally, the research provided an in-depth discussion on the assembly instructions supported by the compiler and elucidated their role in the code generation process.

Building on these foundations, we successfully constructed a compiler capable of producing 64-bit Windows executables. Each module within the compiler was identified and its function described in detail. The resulting skeleton serves as a robust framework upon which further features can be implemented, thereby facilitating the extension of the compiler's capabilities to support an arbitrary set of advanced functionalities.

The next steps in the development of the Benex language would focus on three key areas:
- Standard Libbaries: By integrating comprehensive data structures, such as hashmaps, and abstracting away the need for direct interactions with operating system specific functions, the language can achieve greater portability and ease of use for developers across different platforms.
- Better diagnostics: Another area for improvement lies in the refinement of diagnostic capabilities. Enhancing error messages to be more informative and user friendly could significantly improve the developer experience, particularly during complex code generation or debugging sessions. Additionally, adding support for debugers, like including sysmbol information in the binary file, would allow existing tools to be usable with the language.
- Support for multiple backend architectures: Finally, extending the compiler's target architecture beyond x86 to include platforms such as ARM, or other architectures that are primarily used in embedded systems. This would take advantage of the low level nature of the language, and could be used to enhance the tooling for existing embedded targets.

Collectively, these enhancements have the potential to transform the current prototype into a more robust, versatile, and user centric tool.
